<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0b1220">
  <title>HostelWorld Price Explorer</title>
  <script>
    // Tailwind CDN config (media dark mode + soft shadows)
    window.tailwind = { config: { darkMode: 'media', theme: { extend: { boxShadow: { soft: '0 2px 10px rgba(0,0,0,.06), 0 1px 3px rgba(0,0,0,.06)' } } } } };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
  <style>
    .scroll-shadow { box-shadow: inset 0 -8px 8px -8px rgba(0,0,0,.15); }
    @media (prefers-color-scheme: dark) {
      .scroll-shadow { box-shadow: inset 0 -8px 8px -8px rgba(255,255,255,.08); }
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-900 dark:bg-slate-950 dark:text-slate-100">
  <!-- Header -->
  <header class="sticky top-0 z-10 bg-gradient-to-r from-indigo-600 via-violet-600 to-fuchsia-600 text-white">
    <div class="max-w-6xl mx-auto px-4 py-5 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
      <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">HostelWorld Price Explorer</h1>
      <p class="text-sm/5 md:text-base text-white/90">Understand when dorms are cheap — at a glance.</p>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 py-6 space-y-6">
    <!-- Input card -->
    <section class="bg-white dark:bg-slate-900 rounded-2xl p-4 md:p-6 shadow-soft">
      <form id="inputForm" class="grid grid-cols-1 md:grid-cols-12 gap-3 md:gap-4 items-end" autocomplete="off">
        <div class="md:col-span-7">
          <label class="block text-sm font-medium mb-1" for="urlInput">Hostelworld URL <span class="text-slate-500 dark:text-slate-400 font-normal">(or Property ID)</span></label>
          <input id="urlInput" inputmode="url" autocapitalize="none" spellcheck="false" autocomplete="off" autofocus
                 placeholder="e.g. https://www.hostelworld.com/pwa/hosteldetails.php/.../285693?... or 285693"
                 class="w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-950 px-3 py-2.5 focus:border-indigo-500 focus:ring-indigo-500" />
        </div>
        <div class="md:col-span-3">
          <label class="block text-sm font-medium mb-1" for="checkin">Check‑in (optional)</label>
          <input id="checkin" type="date" class="w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-950 px-3 py-2.5 focus:border-indigo-500 focus:ring-indigo-500" />
        </div>
        <div class="md:col-span-1">
          <label class="block text-sm font-medium mb-1" for="nights">Nights</label>
          <input id="nights" type="number" min="1" max="30" value="1" class="w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-950 px-3 py-2.5 focus:border-indigo-500 focus:ring-indigo-500" />
        </div>
        <div class="md:col-span-1 flex gap-2">
          <button id="analyzeBtn" type="submit" class="w-full rounded-xl bg-indigo-600 text-white px-3 py-3 font-medium hover:bg-indigo-700 active:bg-indigo-800 transition">Analyze</button>
        </div>
      </form>
      <p class="text-xs text-slate-600 dark:text-slate-400 mt-2">Tip: If the Hostelworld URL contains <code>?from=YYYY-MM-DD&to=YYYY-MM-DD</code>, check‑in & nights are auto‑detected. The page URL will be updated so you can refresh or share it.</p>
    </section>

    <!-- Status / errors -->
    <section id="statusBox" class="hidden bg-amber-50 border border-amber-200 text-amber-900 dark:bg-amber-900/20 dark:border-amber-900/40 dark:text-amber-200 rounded-2xl p-4"></section>

    <!-- Summary -->
    <section id="summary" class="hidden bg-white dark:bg-slate-900 rounded-2xl p-4 md:p-6 shadow-soft">
      <div class="grid grid-cols-2 md:grid-cols-4 gap-3 md:gap-4">
        <div class="rounded-xl border border-slate-200 dark:border-slate-800 p-3">
          <div class="text-xs text-slate-500 dark:text-slate-400">Property ID</div>
          <div id="sumPropertyId" class="text-lg font-semibold">–</div>
        </div>
        <div class="rounded-xl border border-slate-200 dark:border-slate-800 p-3">
          <div class="text-xs text-slate-500 dark:text-slate-400">Currency</div>
          <div id="sumCurrency" class="text-lg font-semibold">–</div>
        </div>
        <div class="rounded-xl border border-slate-200 dark:border-slate-800 p-3">
          <div class="text-xs text-slate-500 dark:text-slate-400">Rows</div>
          <div id="sumRows" class="text-lg font-semibold">–</div>
        </div>
        <div class="rounded-xl border border-slate-200 dark:border-slate-800 p-3">
          <div class="text-xs text-slate-500 dark:text-slate-400">Source</div>
          <div class="text-sm"><a id="sumSourceLink" href="#" target="_blank" class="text-indigo-600 dark:text-indigo-400 underline underline-offset-2">Open CSV</a></div>
        </div>
      </div>
    </section>

    <!-- With dates: crawl-time evolution for the stay -->
    <section id="withDates" class="hidden bg-white dark:bg-slate-900 rounded-2xl p-4 md:p-6 shadow-soft space-y-4">
      <h2 class="text-xl md:text-2xl font-semibold">Price evolution per dorm (by crawl time)</h2>
      <p class="text-sm text-slate-600 dark:text-slate-400">For your stay, each point shows the cheapest observed total (min per night across plans, then summed) at that crawl time. X = crawl time, Y = total stay price per dorm.</p>
      <div class="bg-slate-50 dark:bg-slate-800/40 rounded-xl p-3 h-[320px] md:h-[380px]">
        <canvas id="crawlChart" aria-label="Crawl-time price chart" role="img"></canvas>
      </div>
      <div class="overflow-x-auto scroll-shadow rounded-xl border border-slate-200 dark:border-slate-800">
        <table class="min-w-full text-sm">
          <thead class="bg-slate-100 dark:bg-slate-800/60">
            <tr>
              <th class="text-left p-2">Dorm</th>
              <th class="text-right p-2">Min total</th>
              <th class="text-right p-2">Max total</th>
              <th class="text-right p-2">Last crawl</th>
              <th class="text-right p-2">First crawl</th>
            </tr>
          </thead>
          <tbody id="withDatesTable"></tbody>
        </table>
      </div>
    </section>

    <!-- No dates: 14-day min/max per booking date -->
    <section id="noDates" class="hidden bg-white dark:bg-slate-900 rounded-2xl p-4 md:p-6 shadow-soft space-y-4">
      <h2 class="text-xl md:text-2xl font-semibold">14‑day range (min/max) per booking date</h2>
      <div class="flex flex-col md:flex-row gap-3 md:items-end">
        <div class="md:w-96">
          <label class="block text-sm font-medium mb-1" for="dormSelect">Dorm</label>
          <select id="dormSelect" class="w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-950 px-3 py-2.5 focus:border-indigo-500 focus:ring-indigo-500"></select>
        </div>
        <div class="text-sm text-slate-600 dark:text-slate-400">Window: next 14 days from today.</div>
      </div>
      <div class="bg-slate-50 dark:bg-slate-800/40 rounded-xl p-3 h-[320px] md:h-[380px]">
        <canvas id="spanChart" aria-label="14-day min/max chart" role="img"></canvas>
      </div>
      <div class="overflow-x-auto scroll-shadow rounded-xl border border-slate-200 dark:border-slate-800">
        <table class="min-w-full text-sm">
          <thead class="bg-slate-100 dark:bg-slate-800/60">
            <tr>
              <th class="text-left p-2">Date</th>
              <th class="text-right p-2">Min</th>
              <th class="text-right p-2">Max</th>
              <th class="text-right p-2">Range</th>
            </tr>
          </thead>
          <tbody id="noDatesTable"></tbody>
        </table>
      </div>
    </section>

    <footer class="text-xs text-slate-600 dark:text-slate-400 pt-2 md:pt-6">
      <p>Data is loaded directly from GitHub. Timezone: Europe/Berlin.</p>
    </footer>
  </main>

<script>
// ===== Locale helpers =====
const userLocale = navigator.language || 'en-US';
const fmtMoney = (v, c = 'AUD') => {
  const n = Number.isFinite(v) ? v : NaN;
  if (!Number.isFinite(n)) return '–';
  return new Intl.NumberFormat(userLocale, { style: 'currency', currency: c }).format(n);
};
const pad2 = (n) => String(n).padStart(2, '0');
const toDateStr = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
const addDaysStr = (dateStr, days) => {
  const [y,m,d] = dateStr.split('-').map(Number);
  const dt = new Date(Date.UTC(y, m-1, d));
  dt.setUTCDate(dt.getUTCDate() + days);
  return `${dt.getUTCFullYear()}-${pad2(dt.getUTCMonth()+1)}-${pad2(dt.getUTCDate())}`;
};
const rangeDates = (startStr, nights) => {
  const n = Math.max(1, Math.min(30, Number(nights)||1));
  return Array.from({length:n}, (_,i)=> addDaysStr(startStr, i));
};

function parseUrlForDates(u) {
  try {
    const url = new URL(u);
    const from = url.searchParams.get('from') || url.searchParams.get('dateFrom') || url.searchParams.get('checkin');
    const to   = url.searchParams.get('to')   || url.searchParams.get('dateTo')   || url.searchParams.get('checkout');
    if (from && to) {
      const a = new Date(from), b = new Date(to);
      if (!isNaN(a) && !isNaN(b)) {
        const diff = Math.max(1, Math.round((b - a) / 86400000));
        return { from: from.slice(0,10), nights: diff };
      }
    }
  } catch {}
  return null;
}

function extractPropertyId(input) {
  const s = (input||'').trim();
  if (!s) return null;
  if (/^\d{3,10}$/.test(s)) return s;
  try {
    const url = new URL(s);
    const m1 = url.pathname.match(/\/p\/(\d+)(?:\/|$)/);
    if (m1) return m1[1];
    const m2 = url.pathname.match(/hosteldetails\.php\/[\w-]+\/[\w-]+\/(\d+)(?:\/|$)/i);
    if (m2) return m2[1];
    const parts = url.pathname.split('/').filter(Boolean);
    const lastNum = parts.map(p=>p.match(/^(\d{3,10})$/)).filter(Boolean).pop();
    if (lastNum) return lastNum[1];
  } catch {}
  return null;
}

function showStatus(msg, type='info') {
  const box = document.getElementById('statusBox');
  box.classList.remove('hidden');
  box.classList.toggle('bg-amber-50', type==='info');
  box.classList.toggle('border-amber-200', type==='info');
  box.classList.toggle('text-amber-900', type==='info');
  box.classList.toggle('dark:bg-amber-900/20', type==='info');
  box.classList.toggle('dark:border-amber-900/40', type==='info');
  box.classList.toggle('dark:text-amber-200', type==='info');
  box.classList.toggle('bg-red-50', type==='error');
  box.classList.toggle('border-red-200', type==='error');
  box.classList.toggle('text-red-900', type==='error');
  box.classList.toggle('dark:bg-red-900/20', type==='error');
  box.classList.toggle('dark:border-red-900/40', type==='error');
  box.classList.toggle('dark:text-red-200', type==='error');
  box.innerText = msg;
}
function hideStatus(){ document.getElementById('statusBox').classList.add('hidden'); }

// ===== CSV loading =====
const REPOS = ['adverbdizzy7d/HW-AUS', 'adverbdizzy7d/HW-NZL'];

async function fetchCsvForProperty(propertyId) {
  const allCandidates = REPOS.flatMap(repo => [
    //`https://raw.githubusercontent.com/${repo}/refs/heads/main/${propertyId}.csv`,
    //`https://raw.githubusercontent.com/${repo}/main/${propertyId}.csv`,
    `https://raw.githubusercontent.com/${repo}/refs/heads/main/${propertyId}_prices_history.csv`,
    //`https://raw.githubusercontent.com/${repo}/main/${propertyId}_prices_history.csv`,
  ]);

  const fetchAndParse = async (url) => {
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`${res.status} ${res.statusText} for ${url}`);
    const text = await res.text();
    const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
    if (!parsed.data || !parsed.data.length) throw new Error(`Empty CSV from ${url}`);
    return { rows: parsed.data, sourceUrl: url };
  };

  try {
    return await Promise.any(allCandidates.map(fetchAndParse));
  } catch (e) {
    console.error('All CSV fetches failed:', e.errors);
    throw new Error('CSV not found in any repository');
  }
}

// ===== Transformations =====
function normalizeRows(rows) {
  return rows.map(r => ({
    dormId: String(r.dormId ?? r.dorm_id ?? r.dorm ?? ''),
    ratePlan: String(r.ratePlan ?? r.rate_plan ?? ''),
    date: String(r.date ?? '').slice(0,10),
    priceValue: Number(r.priceValue ?? r.price_value ?? r.price),
    priceCurrency: String(r.priceCurrency ?? r.currency ?? 'AUD'),
    crawledAt: Number(r.crawledAt ?? r.crawled_at ?? r.crawl_ts),
    urlPart: r.urlPart ? String(r.urlPart) : ''
  })).filter(r => r.dormId && r.date && Number.isFinite(r.priceValue) && Number.isFinite(r.crawledAt));
}

function groupBy(arr, keyFn) {
  const m = new Map();
  for (const it of arr) {
    const k = keyFn(it);
    if (!m.has(k)) m.set(k, []);
    m.get(k).push(it);
  }
  return m;
}

// ===== Dorm name resolution via raw-data JSON =====
function findOptimalJsonFiles(rows) {
  // First, get all unique dorm IDs we need to resolve
  const neededDormIds = new Set(rows.map(r => r.dormId));
  
  // Group rows by urlPart to find which JSON might contain which dorms
  const byUrlPart = new Map();
  for (const row of rows) {
    if (!row.urlPart) continue;
    if (!byUrlPart.has(row.urlPart)) {
      byUrlPart.set(row.urlPart, {
        dormIds: new Set(),
        latestCrawl: row.crawledAt,
        count: 0
      });
    }
    const entry = byUrlPart.get(row.urlPart);
    entry.dormIds.add(row.dormId);
    entry.count++;
    if (row.crawledAt > entry.latestCrawl) {
      entry.latestCrawl = row.crawledAt;
    }
  }

  // Sort urlParts by how many needed dorms they contain
  const sortedParts = Array.from(byUrlPart.entries())
    .sort((a, b) => {
      // First by number of needed dorms contained
      const aNeeded = new Set([...a[1].dormIds].filter(id => neededDormIds.has(id))).size;
      const bNeeded = new Set([...b[1].dormIds].filter(id => neededDormIds.has(id))).size;
      if (bNeeded !== aNeeded) return bNeeded - aNeeded;
      // Then by recency (latest crawl time)
      return b[1].latestCrawl - a[1].latestCrawl;
    });

  // Build minimal set of files needed to resolve all dorms
  const result = [];
  const resolvedDormIds = new Set();
  
  for (const [urlPart, info] of sortedParts) {
    // Check if this urlPart contains any dorms we still need
    const newDorms = new Set([...info.dormIds].filter(id => 
      neededDormIds.has(id) && !resolvedDormIds.has(id)
    ));
    
    if (newDorms.size > 0) {
      result.push({
        urlPart,
        newDormIds: newDorms,
        crawledAt: info.latestCrawl
      });
      for (const id of newDorms) resolvedDormIds.add(id);
    }

    // Stop if we found all needed dorms
    if (resolvedDormIds.size === neededDormIds.size) break;
  }

  return {
    files: result,
    totalNeeded: neededDormIds.size,
    resolved: resolvedDormIds.size
  };
}

async function fetchDormNamesFromRows(rows, propertyId, sourceUrl) {
  try {
    const repoFromUrl = sourceUrl.match(/raw\.githubusercontent\.com\/([^/]+\/[^/]+)\//)?.[1];
    const reposToTry = repoFromUrl ? [repoFromUrl, ...REPOS.filter(r => r !== repoFromUrl)] : REPOS;
    
    // Find optimal set of JSON files to fetch
    const plan = findOptimalJsonFiles(rows);
    console.log(`Need to resolve ${plan.totalNeeded} dorm names, found ${plan.resolved} in ${plan.files.length} files`);
    
    // Fetch and process each needed file
    const names = new Map();
    for (const file of plan.files) {
      for (const repo of reposToTry) {
        const urls = [
          `https://raw.githubusercontent.com/${repo}/refs/heads/raw-data/raw/${file.urlPart}`,
          //`https://raw.githubusercontent.com/${repo}/raw-data/raw/${file.urlPart}`,
        ];
        
        for (const url of urls) {
          try {
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) continue;
            const json = await res.json();
            
            // Extract dorm names from JSON
            const dorms = json?.rooms?.dorms || [];
            for (const d of dorms) {
              if (d.id && file.newDormIds.has(String(d.id))) {
                const name = d.name || d.roomName || d.title || `Dorm ${d.id}`;
                names.set(String(d.id), String(name));
              }
            }
            
            // If we successfully processed this file, move to next one
            break;
          } catch(e) {
            console.warn(`Failed to fetch/parse ${url}:`, e);
            continue;
          }
        }
      }
    }
    
    return names;
  } catch (e) {
    console.warn('Failed to resolve dorm names:', e);
    return new Map();
  }
}

// Add this function after fetchDormNamesFromRows
async function fetchPropertyName(propertyId, sourceUrl) {
  try {
    const repoFromUrl = sourceUrl.match(/raw\.githubusercontent\.com\/([^/]+\/[^/]+)\//)?.[1];
    const reposToTry = repoFromUrl ? [repoFromUrl, ...REPOS.filter(r => r !== repoFromUrl)] : REPOS;
    
    // Try to get the latest property JSON
    for (const repo of reposToTry) {
      try {
        // Try to get the property history first to find latest JSON
        const historyUrl = `https://raw.githubusercontent.com/${repo}/refs/heads/raw-data/${propertyId}_property_history.csv`;
        const historyRes = await fetch(historyUrl, { cache: 'no-store' });
        if (historyRes.ok) {
          const text = await historyRes.text();
          const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
          if (parsed.data && parsed.data.length) {
            // Get latest JSON URL from history
            const latest = parsed.data.sort((a,b) => b.crawledAt - a.crawledAt)[0];
            if (latest?.urlPart) {
              const jsonUrl = `https://raw.githubusercontent.com/${repo}/refs/heads/raw-data/raw/${latest.urlPart}`;
              const jsonRes = await fetch(jsonUrl, { cache: 'no-store' });
              if (jsonRes.ok) {
                const json = await jsonRes.json();
                if (json?.name) return json.name;
              }
            }
          }
        }
      } catch(e) {
        console.warn(`Failed to get property name from ${repo}:`, e);
      }
    }
  } catch(e) {
    console.warn('Failed to resolve property name:', e);
  }
  return null;
}

// ===== With check-in: build time-series per crawl =====
function seriesForStay(rows, stayDates) {
  const byDorm = groupBy(rows.filter(r => stayDates.has(r.date)), r => r.dormId);
  const out = [];
  for (const [dormId, items] of byDorm) {
    const byCrawl = groupBy(items, r => r.crawledAt);
    const points = [];
    
    for (const [crawlTs, list] of byCrawl) {
      const localDate = new Date(Number(crawlTs) * 1000);
      const byDate = groupBy(list, r => r.date);
      let total = 0;
      let currency = list[0].priceCurrency || 'AUD';
      let unavailableDates = [];
      
      // Check availability for each required date
      for (const date of stayDates) {
        const entries = byDate.get(date) || [];
        if (entries.length === 0) {
          unavailableDates.push(date);
          continue;
        }
        const minForDate = Math.min(...entries.map(e => e.priceValue));
        total += minForDate;
      }
      
      // Only add point if we have prices for all dates
      if (unavailableDates.length === 0) {
        points.push({ x: localDate, y: total, currency, available: true });
      } else {
        points.push({ 
          x: localDate, 
          y: null, 
          currency,
          available: false,
          unavailableDates
        });
      }
    }
    
    points.sort((a,b) => a.x - b.x);
    const availablePoints = points.filter(p => p.available);
    const ys = availablePoints.map(p => p.y);
    
    // Get current availability status
    const lastPoint = points[points.length - 1];
    const currentlyAvailable = lastPoint?.available ?? false;
    const lastAvailablePrice = availablePoints[availablePoints.length - 1]?.y;
    
    out.push({ 
      dormId, 
      points,
      min: ys.length > 0 ? Math.min(...ys) : null,
      max: ys.length > 0 ? Math.max(...ys) : null,
      first: availablePoints[0]?.y ?? null,
      last: lastAvailablePrice ?? null,
      currency: points[0]?.currency || 'AUD',
      currentlyAvailable,
      everAvailable: availablePoints.length > 0,
      lastUnavailableDates: !currentlyAvailable ? lastPoint?.unavailableDates : null
    });
  }
  return out.sort((a,b) => a.dormId.localeCompare(b.dormId));
}

// ===== Without check-in: 14-day min/max per date =====
function minMaxNext14(rows) {
  const today = new Date();
  today.setHours(0,0,0,0);
  const startStr = toDateStr(today);
  const days = Array.from({length:14}, (_,i)=> addDaysStr(startStr, i));

  const byDorm = groupBy(rows.filter(r => days.includes(r.date)), r => r.dormId);
  const byDormOut = new Map();
  for (const [dormId, items] of byDorm) {
    const byDate = groupBy(items, r => r.date);
    const rowsOut = [];
    for (const dStr of days) {
      const list = byDate.get(dStr) || [];
      if (!list.length) { rowsOut.push({ date: dStr, min: NaN, max: NaN, currency: 'AUD' }); continue; }
      const vals = list.map(e => e.priceValue);
      const min = Math.min(...vals), max = Math.max(...vals);
      const currency = list[0].priceCurrency || 'AUD';
      rowsOut.push({ date: dStr, min, max, currency });
    }
    byDormOut.set(dormId, rowsOut);
  }
  return { days, byDorm: byDormOut };
}

// ===== Charts with robust auto-scaling =====
let crawlChart, spanChart;
function computeYDomainFromArrays(arrays) {
  const values = arrays.flat().filter(v => Number.isFinite(v));
  if (!values.length) return { min: 0, max: 1 };
  let min = Math.min(...values);
  let max = Math.max(...values);
  if (min === max) {
    const pad = Math.max(1, Math.abs(max) * 0.05);
    return { min: min - pad, max: max + pad };
  }
  const pad = (max - min) * 0.06;
  return { min: min - pad, max: max + pad };
}

function renderCrawlChart(series, dormNames) {
  const ctx = document.getElementById('crawlChart').getContext('2d');
  if (crawlChart) { crawlChart.destroy(); }
  
  const datasets = series.map(s => ({
    label: dormNames.get(String(s.dormId)) || `Dorm ${s.dormId}`,
    data: s.points.map(p => ({ 
      x: p.x, 
      y: p.y 
    })),
    fill: false,
    tension: 0.25,
    spanGaps: true // Allow gaps for unavailable dates
  }));
  
  const currency = series[0]?.currency || 'AUD';
  const domain = computeYDomainFromArrays(datasets.map(d => d.data.map(p => p.y).filter(y => y !== null)));
  
  crawlChart = new Chart(ctx, {
    type: 'line',
    data: { datasets },
    options: {
      maintainAspectRatio: false,
      responsive: true,
      interaction: { mode: 'nearest', intersect: false },
      plugins: {
        legend: { 
          position: 'bottom',
          // Nach Änderung der Sichtbarkeit Y-Achse neu berechnen
          onClick: (evt, legendItem, legend) => {
            const index = legendItem.datasetIndex;
            const chart = legend.chart;
            chart.getDatasetMeta(index).hidden = !chart.getDatasetMeta(index).hidden;
            
            // Berechne neue Y-Achsen Grenzen nur für sichtbare Datensätze
            const visibleData = datasets
              .filter((d, i) => !chart.getDatasetMeta(i).hidden)
              .map(d => d.data.map(p => p.y));
            
            if (visibleData.length > 0) {
              const newDomain = computeYDomainFromArrays(visibleData);
              chart.options.scales.y.min = newDomain.min;
              chart.options.scales.y.max = newDomain.max;
            }
            
            chart.update();
          }
        },
        tooltip: { 
          callbacks: { 
            label: (ctx) => {
              const localTime = ctx.raw.x.toLocaleString(userLocale);
              return `${ctx.dataset.label}: ${fmtMoney(ctx.parsed.y, currency)} @ ${localTime}`;
            }
          }
        }
      },
      scales: {
        x: { 
          type: 'time',
          time: { 
            tooltipFormat: 'PP HH:mm',
            displayFormats: {
              datetime: 'PP HH:mm',
              millisecond: 'HH:mm:ss.SSS',
              second: 'HH:mm:ss',
              minute: 'HH:mm',
              hour: 'HH:mm'
            }
          }
        },
        y: { 
          min: domain.min, 
          max: domain.max, 
          ticks: { callback: (v)=>fmtMoney(v, currency) }
        }
      }
    }
  });
}

function renderSpanChart(dayRows, dormId, dormName) {
  const ctx = document.getElementById('spanChart').getContext('2d');
  if (spanChart) { spanChart.destroy(); }
  const labels = dayRows.map(r => r.date);
  const minVals = dayRows.map(r => r.min);
  const maxVals = dayRows.map(r => r.max);
  const currency = dayRows[0]?.currency || 'AUD';
  const domain = computeYDomainFromArrays([minVals, maxVals]);
  spanChart = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets: [
      { label: `Min`, data: minVals, spanGaps: true, tension: 0.25 },
      { label: `Max`, data: maxVals, spanGaps: true, tension: 0.25 },
    ]},
    options: {
      maintainAspectRatio: false,
      responsive: true,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        title: { display: true, text: dormName },
        legend: { position: 'bottom' },
        tooltip: { callbacks: { label: (ctx)=> `${ctx.dataset.label}: ${fmtMoney(ctx.parsed.y, currency)}` } }
      },
      scales: { y: { min: domain.min, max: domain.max, ticks: { callback: (v)=>fmtMoney(v, currency) } } }
    }
  });
}

// ===== Tables =====
function renderWithDatesTable(series, dormNames) {
  const tb = document.getElementById('withDatesTable');
  tb.innerHTML = '';
  for (const s of series) {
    const tr = document.createElement('tr');
    const label = dormNames.get(String(s.dormId)) || `Dorm ${s.dormId}`;
    const availabilityClass = s.currentlyAvailable ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400';
    const availabilityText = s.currentlyAvailable ? 
      'Available' : 
      (s.everAvailable ? 
        `Not available (dates: ${s.lastUnavailableDates.join(', ')})` : 
        'Never available');
    
    tr.innerHTML = `
      <td class="p-2">
        ${label}
        <div class="text-xs ${availabilityClass}">${availabilityText}</div>
      </td>
      <td class="p-2 text-right">${s.min !== null ? fmtMoney(s.min, s.currency) : '–'}</td>
      <td class="p-2 text-right">${s.max !== null ? fmtMoney(s.max, s.currency) : '–'}</td>
      <td class="p-2 text-right">${s.last !== null ? fmtMoney(s.last, s.currency) : '–'}</td>
      <td class="p-2 text-right">${s.first !== null ? fmtMoney(s.first, s.currency) : '–'}</td>
    `;
    tb.appendChild(tr);
  }
}

function renderNoDatesTable(rows) {
  const tb = document.getElementById('noDatesTable');
  tb.innerHTML = '';
  for (const r of rows) {
    const span = (Number.isFinite(r.min) && Number.isFinite(r.max)) ? (r.max - r.min) : NaN;
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="p-2">${r.date}</td>
      <td class="p-2 text-right">${fmtMoney(r.min, r.currency)}</td>
      <td class="p-2 text-right">${fmtMoney(r.max, r.currency)}</td>
      <td class="p-2 text-right">${Number.isFinite(span) ? fmtMoney(span, r.currency) : '–'}</td>
    `;
    tb.appendChild(tr);
  }
}

// ===== URL helpers (deep-links) =====
function updateQueryString({ id, from, nights }) {
  const q = new URLSearchParams(window.location.search);
  q.set('id', id);
  if (from) {
    q.set('from', from);
    if (nights) q.set('nights', String(nights));
    q.delete('to'); // avoid ambiguity
  } else {
    q.delete('from'); q.delete('to'); q.delete('nights');
  }
  const newUrl = `${location.pathname}?${q.toString()}`;
  history.replaceState(null, '', newUrl);
}

function bootstrapFromQuery() {
  try {
    const q = new URLSearchParams(location.search);
    const id = q.get('id');
    const from = q.get('from');
    const to = q.get('to');
    const nights = q.get('nights');
    if (id) document.getElementById('urlInput').value = id;
    if (from && to) {
      const a = new Date(from), b = new Date(to);
      if (!isNaN(a) && !isNaN(b)) {
        document.getElementById('checkin').value = from.slice(0,10);
        const diff = Math.max(1, Math.round((b - a) / 86400000));
        document.getElementById('nights').value = diff;
      }
    } else if (from && nights) {
      document.getElementById('checkin').value = from.slice(0,10);
      document.getElementById('nights').value = Math.max(1, Number(nights)||1);
    }
    if (id) { runAnalysis(); }
  } catch {}
}

// ===== Property History Tracking =====
async function fetchPropertyHistory(propertyId) {
  const allCandidates = REPOS.flatMap(repo => [
    `https://raw.githubusercontent.com/${repo}/refs/heads/raw-data/${propertyId}_property_history.csv`,
  ]);

  const fetchAndParse = async (url) => {
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`${res.status} ${res.statusText} for ${url}`);
    const text = await res.text();
    const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
    if (!parsed.data || !parsed.data.length) throw new Error(`Empty CSV from ${url}`);
    
    // Filter to last 30 days
    const thirtyDaysAgo = Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60);
    const filteredRows = parsed.data.filter(row => row.crawledAt >= thirtyDaysAgo);
    
    return { 
      rows: filteredRows.sort((a,b) => b.crawledAt - a.crawledAt),
      sourceUrl: url,
      totalRows: parsed.data.length,
      filteredRows: filteredRows.length
    };
  };

  try {
    return await Promise.any(allCandidates.map(fetchAndParse));
  } catch (e) {
    console.error('Property history CSV fetch failed:', e.errors);
    throw new Error('Property history not found');
  }
}

function compareObjects(prev, curr) {
  const changes = [];
  const seen = new Set();

  function recordChange(path, oldVal, newVal) {
    changes.push({
      path: path.join('.'),
      old: oldVal,
      new: newVal,
      type: oldVal === undefined ? 'added' : newVal === undefined ? 'removed' : 'changed'
    });
  }

  function traverse(a, b, path = []) {
    if (a === b) return;
    const pathKey = path.join('.');
    if (seen.has(pathKey)) return;
    seen.add(pathKey);

    if (Array.isArray(a) && Array.isArray(b)) {
      // Special handling for promotions array - compare by ID
      if (path[path.length-1] === 'promotions') {
        const aMap = new Map(a.map(p => [p.id, p]));
        const bMap = new Map(b.map(p => [p.id, p]));
        
        // Find removed and changed promotions
        for (const [id, promoA] of aMap) {
          const promoB = bMap.get(id);
          if (!promoB) {
            recordChange([...path, id], promoA, undefined);
          } else if (JSON.stringify(promoA) !== JSON.stringify(promoB)) {
            recordChange([...path, id], promoA, promoB);
          }
        }
        
        // Find new promotions
        for (const [id, promoB] of bMap) {
          if (!aMap.has(id)) {
            recordChange([...path, id], undefined, promoB);
          }
        }
        return;
      }
      
      // For other arrays, compare elements directly
      const len = Math.max(a.length, b.length);
      for (let i = 0; i < len; i++) {
        traverse(a[i], b[i], [...path, i]);
      }
      return;
    }

    if (a && b && typeof a === 'object' && typeof b === 'object') {
      const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
      for (const key of keys) {
        traverse(a[key], b[key], [...path, key]);
      }
      return;
    }

    if (a !== b) {
      recordChange(path, a, b);
    }
  }

  traverse(prev, curr);
  return changes;
}

function formatValue(v) {
  if (v === undefined) return '(undefined)';
  if (v === null) return '(null)';
  if (typeof v === 'object') return JSON.stringify(v, null, 2);
  return String(v);
}

async function fetchAndComparePropertyVersions(propertyId, history) {
  const repoFromUrl = history.sourceUrl.match(/raw\.githubusercontent\.com\/([^/]+\/[^/]+)\//)?.[1];
  const reposToTry = repoFromUrl ? [repoFromUrl, ...REPOS.filter(r => r !== repoFromUrl)] : REPOS;
  
  // Track promotions by ID
  const promotionHistory = new Map(); // promoId -> {versions: [{json, start, end}]}
  
  // Process all versions chronologically (oldest first)
  const sortedEntries = [...history.rows].sort((a,b) => a.crawledAt - b.crawledAt);
  
  for (const entry of sortedEntries) {
    for (const repo of reposToTry) {
      try {
        const url = `https://raw.githubusercontent.com/${repo}/refs/heads/raw-data/raw/${entry.urlPart}`;
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) continue;
        const json = await res.json();
        
        // Extract promotions
        const promotions = json.promotions || [];
        for (const promo of promotions) {
          if (!promotionHistory.has(promo.id)) {
            promotionHistory.set(promo.id, { versions: [] });
          }
          const history = promotionHistory.get(promo.id);
          const lastVersion = history.versions[history.versions.length - 1];
          
          // Check if this is a new version
          if (!lastVersion || JSON.stringify(lastVersion.json) !== JSON.stringify(promo)) {
            // Close previous version if exists
            if (lastVersion) {
              lastVersion.end = entry.crawledAt;
            }
            // Start new version
            history.versions.push({
              json: promo,
              start: entry.crawledAt,
              end: null // will be set when a new version is found or at the end
            });
          }
        }
        break;
      } catch(e) {
        console.warn(`Failed to fetch/parse property JSON from ${repo}:`, e);
        continue;
      }
    }
  }
  
  // Close end dates for last versions
  const lastCrawl = Math.max(...history.rows.map(r => r.crawledAt));
  for (const history of promotionHistory.values()) {
    const lastVersion = history.versions[history.versions.length - 1];
    if (lastVersion && !lastVersion.end) {
      lastVersion.end = lastCrawl;
    }
  }
  
  return promotionHistory;
}

function formatPromotion(promo) {
  return JSON.stringify(promo, null, 2)
    .split('\n')
    .map(line => `    ${line}`)
    .join('\n');
}

function formatTimestamp(ts) {
  return new Date(ts * 1000).toLocaleString(userLocale);
}

function formatDateRange(start, end) {
  return `${formatTimestamp(start)} → ${end ? formatTimestamp(end) : 'now'}`;
}

function renderPropertyHistory(promotionHistory) {
  let section = document.getElementById('propertyHistory');
  if (!section) {
    section = document.createElement('section');
    section.id = 'propertyHistory';
    section.className = 'bg-white dark:bg-slate-900 rounded-2xl p-4 md:p-6 shadow-soft space-y-4';
    document.querySelector('main').insertBefore(section, document.querySelector('footer'));
  }
  
  const promotions = Array.from(promotionHistory.entries())
    .sort(([idA], [idB]) => idA - idB);
  
  section.innerHTML = `
    <h2 class="text-xl md:text-2xl font-semibold">Promotions History</h2>
    <p class="text-sm text-slate-600 dark:text-slate-400 mb-4">Showing changes from the last 30 days</p>
    <div class="space-y-6">
      ${promotions.map(([id, history]) => `
        <div class="border border-slate-200 dark:border-slate-700 rounded-xl p-4">
          <h3 class="text-lg font-medium mb-2">Promotion ID: ${id}</h3>
          <div class="space-y-4 font-mono text-sm">
            ${history.versions.map((v, i) => `
              <div class="relative">
                <div class="text-slate-500 dark:text-slate-400 mb-1">${formatDateRange(v.start, v.end)}</div>
                <pre class="bg-slate-50 dark:bg-slate-800/50 rounded p-2 overflow-x-auto">${formatPromotion(v.json)}</pre>
                ${i < history.versions.length - 1 ? `
                  <div class="text-amber-600 dark:text-amber-400 mt-2">
                    Changes in next version:
                    <pre class="bg-slate-50 dark:bg-slate-800/50 rounded p-2 mt-1">${highlightChanges(v.json, history.versions[i + 1].json)}</pre>
                  </div>
                ` : ''}
              </div>
            `).join('\n')}
          </div>
        </div>
      `).join('\n')}
    </div>
  `;
  section.classList.remove('hidden');
}

function highlightChanges(oldJson, newJson) {
  const changes = [];
  
  function compareObjects(path, a, b) {
    if (a === b) return;
    
    if (typeof a !== typeof b) {
      changes.push(`${path}: ${JSON.stringify(a)} → ${JSON.stringify(b)}`);
      return;
    }
    
    if (typeof a !== 'object' || a === null || b === null) {
      if (a !== b) changes.push(`${path}: ${JSON.stringify(a)} → ${JSON.stringify(b)}`);
      return;
    }
    
    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        changes.push(`${path}: array → non-array`);
        return;
      }
      for (let i = 0; i < Math.max(a.length, b.length); i++) {
        if (i >= a.length) changes.push(`${path}[${i}]: (added) ${JSON.stringify(b[i])}`);
        else if (i >= b.length) changes.push(`${path}[${i}]: (removed) ${JSON.stringify(a[i])}`);
        else compareObjects(`${path}[${i}]`, a[i], b[i]);
      }
      return;
    }
    
    const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
    for (const key of keys) {
      if (!(key in a)) changes.push(`${path}.${key}: (added) ${JSON.stringify(b[key])}`);
      else if (!(key in b)) changes.push(`${path}.${key}: (removed) ${JSON.stringify(a[key])}`);
      else compareObjects(`${path}.${key}`, a[key], b[key]);
    }
  }
  
  compareObjects('', oldJson, newJson);
  return changes.join('\n');
}

// ===== Init =====
const form = document.getElementById('inputForm');
form.addEventListener('submit', (e) => { e.preventDefault(); runAnalysis(); });
bootstrapFromQuery();

// ===== Main analysis function =====
async function runAnalysis() {
  hideStatus();
  document.getElementById('withDates').classList.add('hidden');
  document.getElementById('noDates').classList.add('hidden');
  document.getElementById('summary').classList.add('hidden');

  const input = document.getElementById('urlInput').value.trim();
  const checkin = document.getElementById('checkin').value;
  const nights = Number(document.getElementById('nights').value || '1');

  // If a Hostelworld URL has dates, auto-fill
  if (input) {
    const auto = parseUrlForDates(input);
    if (auto && !checkin) {
      document.getElementById('checkin').value = auto.from;
      document.getElementById('nights').value = auto.nights;
    }
  }
  const effectiveCheckin = document.getElementById('checkin').value;
  const effectiveNights = Number(document.getElementById('nights').value || '1');

  const propertyId = extractPropertyId(input);
  if (!propertyId) {
    showStatus('Could not extract a Property ID. Please enter a valid Hostelworld URL or a numeric ID.', 'error');
    return;
  }

  showStatus('Loading CSV …');
  let rows, sourceUrl;
  try {
    const res = await fetchCsvForProperty(propertyId);
    rows = normalizeRows(res.rows);
    sourceUrl = res.sourceUrl;
  } catch (e) {
    console.error(e);
    showStatus(`CSV could not be loaded for property ${propertyId}. Make sure the file exists in the repository.\nError: ${e.message}`, 'error');
    return;
  }
  hideStatus();

  // Summary box
  const currency = rows[0]?.priceCurrency || 'AUD';
  document.getElementById('sumPropertyId').innerText = propertyId;
  document.getElementById('sumCurrency').innerText = currency;
  document.getElementById('sumRows').innerText = rows.length.toLocaleString(userLocale);
  const link = document.getElementById('sumSourceLink');
  link.href = sourceUrl;
  link.textContent = sourceUrl.replace('https://raw.githubusercontent.com/','');
  document.getElementById('summary').classList.remove('hidden');

  // Resolve dorm names from latest raw-data JSON (best-effort)
  const rawDormNames = await fetchDormNamesFromRows(rows, propertyId, sourceUrl);
  lastDormNames = new Map();
  for (const [id, name] of rawDormNames.entries()) {
    lastDormNames.set(id, `${name} (${id})`);
  }
  const getDormLabel = (id) => lastDormNames.get(String(id)) || `Dorm ${id}`;


  // Get property name and update title
  try {
    const propertyName = await fetchPropertyName(propertyId, sourceUrl);
    if (propertyName) {
      document.title = `${propertyName} - HostelWorld Price Explorer`;
      document.querySelector('h1').innerHTML = `
        ${propertyName}
        <div class="text-sm font-normal text-white/75">HostelWorld Price Explorer</div>
      `;
    }
  } catch(e) {
    console.warn('Could not fetch property name:', e);
  }

  // Update URL for refresh/share
  if (effectiveCheckin) {
    updateQueryString({ id: propertyId, from: effectiveCheckin, nights: effectiveNights });
  } else {
    updateQueryString({ id: propertyId });
  }

  // Branch by check-in
  if (effectiveCheckin) {
    const stayDates = new Set(rangeDates(effectiveCheckin, effectiveNights));
    const series = seriesForStay(rows, stayDates);
    if (!series.length) {
      showStatus('No matching records for the selected date range. Try a different stay.', 'info');
    }
    renderCrawlChart(series, lastDormNames);
    renderWithDatesTable(series, lastDormNames);
    document.getElementById('withDates').classList.remove('hidden');
  } else {
    const agg = minMaxNext14(rows);
    const dormIds = Array.from(agg.byDorm.keys()).sort();
    const select = document.getElementById('dormSelect');
    select.innerHTML = '';
    for (const d of dormIds) {
      const label = getDormLabel(d);
      const opt = document.createElement('option');
      opt.value = d; opt.textContent = label;
      select.appendChild(opt);
    }
    const pick = dormIds[0];
    if (!pick) {
      showStatus('No records for the next 14 days were found.', 'info');
      return;
    }
    const rowsForDorm = agg.byDorm.get(pick);
    const label = getDormLabel(pick);
    renderSpanChart(rowsForDorm, pick, label);
    renderNoDatesTable(rowsForDorm);
    document.getElementById('noDates').classList.remove('hidden');

    select.onchange = () => {
      const d = select.value;
      const r = agg.byDorm.get(d) || [];
      const lbl = getDormLabel(d);
      renderSpanChart(r, d, lbl);  // will recompute Y-domain so the graph isn't squashed
      renderNoDatesTable(r);
    };
  }

  // After loading price data, also load property history
  try {
    const historyRes = await fetchPropertyHistory(propertyId);
    const versions = await fetchAndComparePropertyVersions(propertyId, historyRes);
    renderPropertyHistory(versions);
  } catch (e) {
    console.warn('Could not load property history:', e);
  }
}
</script>
</body>
</html>
